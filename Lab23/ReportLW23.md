# Отчет по лабораторной работе № 23
## по курсу "Фундаментальная информатика"

Студент группы М8О-108Б-23 Федорова Екатерина Васильевна

Работа выполнена 

Преподаватель: каф. 806 Севастьянов Виктор Сергеевич

1. **Тема**: Динамические структуры данных. Обработка деревьев.
2. **Цель работы**: Составить программу на языке С для построения и обработки дерева общего вида или упорядоченного двоичного дерева.  
     Основные функции работы с деревьями реализовать в виде универсальных процедур или функций. После того, как дерево создано, его обработка должна производиться в режиме текстового меню со следующими действиями:
    * добавление нового узла;   
    * текстовая визуализация дерева ;  
    * удаление узла;  
    * вычисление значения некоторой функции от дерева (целой или логической), в соответствии с номером варианта.  
3. **Задание (вариант №22)**: Определить число вершин дерева.
4. **Идея, метод, алгоритм решения задачи**:

Программа запрашивает значение корневого узла, после чего предоставляет пользователю функционал:
* M (Modification) -- позволяет изменить значение любого узла, в т.ч. корневого, без потери предков и потомков.
* C (Create) -- позволяет создать новый узел дерева, прикрепив к любому другому узлу.
* D (Delete) -- позволяет удалить любой узел дерева, кроме корневого. Все поддеревья, исходящие из удаляемого узла, также будут удалены. Для обнуления всего дерева перезагрузите программу.
* P (Painting) -- позволяет в текстовом формате визуализировать дерево.
* A (Account) -- выводит общее количество вершин в дереве с учётом корневого, а также степень дерева.
* Q (Quit) -- выход из программы. При этом существующее дерево полностью удаляется.
* H (Help) -- вызов данной справки внутри программы.

Некоторый анализ кода:

1. Структуры данных:
- Node: Структура `Node` представляет узел дерева. Узел содержит данные (`float data`), степень узла (`int degree`), индекс предыдущего узла (`int prev_index`), указатель на предыдущий узел (`struct Node* prev`) и массив узлов-потомков (`struct Node* foliage[100]`).
- Wood: Структура `Wood` используется для обозначения информации о дереве. Она содержит степень дерева (`int degree`), количество вершин в дереве (`int vertex_count`) и указатель на корневой узел (`struct Node* vertex_root`).

2. Функции:
- Create: Инициализирует узел, устанавливая его данные и степень в ноль.
- Search_Degree_Wood: Рекурсивно ищет максимальную степень в дереве, начиная с указанного узла.
- Push: Добавляет новый узел к указанному узлу-отцу в дереве.
- Pop: Удаляет узел и все его потомки из дерева.
- Search: Рекурсивно ищет узел с определенным значением в дереве.
- Val_In_Wood: Проверяет, содержится ли узел с заданным значением в дереве.
- Modification_Node_Data: Меняет данные указанного узла.
- Paint: Осуществляет текстовую визуализацию дерева.

3. Основная программа:
- В функции `main` создается корневой узел дерева и выделяется память для структуры `Wood`.
- В цикле `while` программа предлагает пользователю выбирать перечисленные выше операции.
- Программа завершается, освобождая память и удаляя дерево.

5. **Сценарий выполнения работы**:

Тестовые запуски программы:
```
moscow@moscow:~/Рабочий стол/For Labs/ForLabs/Lab23$ make
rm -f lab23
gcc -std=c99 --pedantic -Wall -o lab23 lab23.c
./lab23
Добро пожаловать!
На данный момент дерева не существует. Введите значение корневого узла: 5.5
Дерево успешно создано!

----------------------------------

M для изменения значения узла,
C для добавления узла,
D для удаления узла,
P для текстовой визуализации,
A для подсчёта количества вершин,
Q для выхода,
H для более подробного описания команд.
Введите букву команды: c
Введите значение для нового узла: 7
Введите значение отцовского узла: 5.5
Узел добавлен.

M для изменения значения узла,
C для добавления узла,
D для удаления узла,
P для текстовой визуализации,
A для подсчёта количества вершин,
Q для выхода,
H для более подробного описания команд.
Введите букву команды: c
Введите значение для нового узла: 9
Введите значение отцовского узла: 7
Узел добавлен.

M для изменения значения узла,
C для добавления узла,
D для удаления узла,
P для текстовой визуализации,
A для подсчёта количества вершин,
Q для выхода,
H для более подробного описания команд.
Введите букву команды: c
Введите значение для нового узла: 2
Введите значение отцовского узла: 5.5
Узел добавлен.

M для изменения значения узла,
C для добавления узла,
D для удаления узла,
P для текстовой визуализации,
A для подсчёта количества вершин,
Q для выхода,
H для более подробного описания команд.
Введите букву команды: c
Введите значение для нового узла: 0
Введите значение отцовского узла: 9
Узел добавлен.

M для изменения значения узла,
C для добавления узла,
D для удаления узла,
P для текстовой визуализации,
A для подсчёта количества вершин,
Q для выхода,
H для более подробного описания команд.
Введите букву команды: c
Введите значение для нового узла: 2.1
Введите значение отцовского узла: 2
Узел добавлен.

M для изменения значения узла,
C для добавления узла,
D для удаления узла,
P для текстовой визуализации,
A для подсчёта количества вершин,
Q для выхода,
H для более подробного описания команд.
Введите букву команды: c
Введите значение для нового узла: 2.2
Введите значение отцовского узла: 2
Узел добавлен.

M для изменения значения узла,
C для добавления узла,
D для удаления узла,
P для текстовой визуализации,
A для подсчёта количества вершин,
Q для выхода,
H для более подробного описания команд.
Введите букву команды: c
Введите значение для нового узла: 1
Введите значение отцовского узла: 9
Узел добавлен.

M для изменения значения узла,
C для добавления узла,
D для удаления узла,
P для текстовой визуализации,
A для подсчёта количества вершин,
Q для выхода,
H для более подробного описания команд.
Введите букву команды: c
Введите значение для нового узла: 2.3
Введите значение отцовского узла: 2
Узел добавлен.

M для изменения значения узла,
C для добавления узла,
D для удаления узла,
P для текстовой визуализации,
A для подсчёта количества вершин,
Q для выхода,
H для более подробного описания команд.
Введите букву команды: a
Степень дерева: 3
Количество вершин в дереве: 9

M для изменения значения узла,
C для добавления узла,
D для удаления узла,
P для текстовой визуализации,
A для подсчёта количества вершин,
Q для выхода,
H для более подробного описания команд.
Введите букву команды: p
5.500000
    7.000000
        9.000000
            0.000000
            1.000000
    2.000000
        2.100000
        2.200000
        2.300000

M для изменения значения узла,
C для добавления узла,
D для удаления узла,
P для текстовой визуализации,
A для подсчёта количества вершин,
Q для выхода,
H для более подробного описания команд.
Введите букву команды: c
Введите значение для нового узла: 2
Введите значение отцовского узла: 2.1
Узел с таким значением уже существует.

M для изменения значения узла,
C для добавления узла,
D для удаления узла,
P для текстовой визуализации,
A для подсчёта количества вершин,
Q для выхода,
H для более подробного описания команд.
Введите букву команды: c
Введите значение для нового узла: 14.341
Введите значение отцовского узла: 76
Память не выделена, количество потомков у узла превышено или узел не найден.

M для изменения значения узла,
C для добавления узла,
D для удаления узла,
P для текстовой визуализации,
A для подсчёта количества вершин,
Q для выхода,
H для более подробного описания команд.
Введите букву команды: c
Введите значение для нового узла: 14.3415472572457457
Введите значение отцовского узла: 2.1
Узел добавлен.

M для изменения значения узла,
C для добавления узла,
D для удаления узла,
P для текстовой визуализации,
A для подсчёта количества вершин,
Q для выхода,
H для более подробного описания команд.
Введите букву команды: p
5.500000
    7.000000
        9.000000
            0.000000
            1.000000
    2.000000
        2.100000
            14.341547
        2.200000
        2.300000

M для изменения значения узла,
C для добавления узла,
D для удаления узла,
P для текстовой визуализации,
A для подсчёта количества вершин,
Q для выхода,
H для более подробного описания команд.
Введите букву команды: d
Введите значение удаляемого узла: 7
Узел удалён.

M для изменения значения узла,
C для добавления узла,
D для удаления узла,
P для текстовой визуализации,
A для подсчёта количества вершин,
Q для выхода,
H для более подробного описания команд.
Введите букву команды: p
5.500000
    2.000000
        2.100000
            14.341547
        2.200000
        2.300000

M для изменения значения узла,
C для добавления узла,
D для удаления узла,
P для текстовой визуализации,
A для подсчёта количества вершин,
Q для выхода,
H для более подробного описания команд.
Введите букву команды: a
Степень дерева: 3
Количество вершин в дереве: 6

M для изменения значения узла,
C для добавления узла,
D для удаления узла,
P для текстовой визуализации,
A для подсчёта количества вершин,
Q для выхода,
H для более подробного описания команд.
Введите букву команды: d
Введите значение удаляемого узла: 5.5
Попытка удаления корневого узла или узел не найден.

M для изменения значения узла,
C для добавления узла,
D для удаления узла,
P для текстовой визуализации,
A для подсчёта количества вершин,
Q для выхода,
H для более подробного описания команд.
Введите букву команды: d
Введите значение удаляемого узла: 654
Попытка удаления корневого узла или узел не найден.

M для изменения значения узла,
C для добавления узла,
D для удаления узла,
P для текстовой визуализации,
A для подсчёта количества вершин,
Q для выхода,
H для более подробного описания команд.
Введите букву команды: M
Введите старое значение узла: 6
Введите новое значение узла: 4
Узел не найден.

M для изменения значения узла,
C для добавления узла,
D для удаления узла,
P для текстовой визуализации,
A для подсчёта количества вершин,
Q для выхода,
H для более подробного описания команд.
Введите букву команды: M
Введите старое значение узла: 14.341547
Введите новое значение узла: 14.3
Значение изменено.

M для изменения значения узла,
C для добавления узла,
D для удаления узла,
P для текстовой визуализации,
A для подсчёта количества вершин,
Q для выхода,
H для более подробного описания команд.
Введите букву команды: p
5.500000
    2.000000
        2.100000
            14.300000
        2.200000
        2.300000

M для изменения значения узла,
C для добавления узла,
D для удаления узла,
P для текстовой визуализации,
A для подсчёта количества вершин,
Q для выхода,
H для более подробного описания команд.
Введите букву команды: h
M (Modification) -- позволяет изменить значение любого узла, в т.ч. корневого, без потери предков и потомков.
C (Create) -- позволяет создать новый узел дерева, прикрепив к любому другому узлу.
D (Delete) -- позволяет удалить любой узел дерева, кроме корневого. Все поддеревья, исходящие из удаляемого узла, также будут удалены. Для обнуления всего дерева перезагрузите программу.
P (Painting) -- позволяет в текстовом формате визуализировать дерево.
A (Account) -- выводит общее количество вершин в дереве с учётом корневого, а также степень дерева.
Q (Quit) -- выход из программы. При этом существующее дерево полностью удаляется.

M для изменения значения узла,
C для добавления узла,
D для удаления узла,
P для текстовой визуализации,
A для подсчёта количества вершин,
Q для выхода,
H для более подробного описания команд.
Введите букву команды: a
Степень дерева: 3
Количество вершин в дереве: 6

M для изменения значения узла,
C для добавления узла,
D для удаления узла,
P для текстовой визуализации,
A для подсчёта количества вершин,
Q для выхода,
H для более подробного описания команд.
Введите букву команды: d 
Введите значение удаляемого узла: 2
Узел удалён.

M для изменения значения узла,
C для добавления узла,
D для удаления узла,
P для текстовой визуализации,
A для подсчёта количества вершин,
Q для выхода,
H для более подробного описания команд.
Введите букву команды: p
5.500000

M для изменения значения узла,
C для добавления узла,
D для удаления узла,
P для текстовой визуализации,
A для подсчёта количества вершин,
Q для выхода,
H для более подробного описания команд.
Введите букву команды: a
Степень дерева: 0
Количество вершин в дереве: 1

M для изменения значения узла,
C для добавления узла,
D для удаления узла,
P для текстовой визуализации,
A для подсчёта количества вершин,
Q для выхода,
H для более подробного описания команд.
Введите букву команды: q

----------------------------------

Удаление дерева...
До свидания!

----------------------------------
moscow@moscow:~/Рабочий стол/For Labs/ForLabs/Lab23$ 
```

6. **Протокол**:

Программа:
```
#include <stdio.h>
#include <stdbool.h>
#include <stdlib.h>

typedef struct Node {
    float data;
    int degree;
    int prev_index;
    struct Node* prev;
    struct Node* foliage[100]; 
} Node;

typedef struct Wood {
    int degree;
    int vertex_count;
    struct Node* vertex_root;
} Wood;

//---------------------------------------
//ФУНКЦИИ ДЛЯ УЗЛОВ ДЕРЕВА

void Create(Node* n){
    n->data = 0;
    n->degree = 0;
    n->prev = 0;
    n->prev_index = 0;
    return;
}

int Search_Degree_Wood(Node* n){
    int max_degree = n->degree;
    for (int i = 0; i < n->degree; i++){
        int degree_subtree = Search_Degree_Wood(n->foliage[i]);
        if (max_degree < degree_subtree){
            max_degree = degree_subtree;
        }
    }
    return max_degree;
}

bool Push(Wood* w, Node* n_father, float val){
    if (n_father == NULL){
        return false;
    }
    if (n_father->degree >= 100){
        return false;
    }
    struct Node* new_n = malloc(sizeof(struct Node));
    if (!new_n){
        return false;
    }
    new_n->data = val;
    new_n->degree = 0;
    new_n->prev = n_father;
    new_n->prev_index = n_father->degree;
    n_father->foliage[n_father->degree] = new_n;
    n_father->degree++;
    w->vertex_count++;
    if (n_father->degree > w->degree){
        w->degree = n_father->degree;
    }
    return true;
}

bool Pop(Wood* w, Node* n){
    if (n == NULL){
        return false;
    }
    if (n->prev == 0){
    	return false;
    }
    for (int i = n->degree-1; i >= 0; i--){
        Pop(w, n->foliage[i]);
    }
    if (n->prev_index != n->prev->degree-1){
        for (int i = n->prev_index; i < n->prev->degree-1; i++){
            n->prev->foliage[i] = n->prev->foliage[i+1];
            n->prev->foliage[i]->prev_index = i;
        }
        n->prev->foliage[n->prev->degree-1] = 0;
    } else n->prev->foliage[n->prev_index] = 0;
    n->prev->degree--;
    free(n);
    w->vertex_count--;
    w->degree = Search_Degree_Wood(w->vertex_root);
    return true;
}

Node* Search(Node* n, float val){
    if (n->data == val){
        return n;
    }
    Node* n_find = NULL;
    for (int i = 0; i < n->degree; i++){
        n_find = Search(n->foliage[i], val);
        if (n_find != NULL){
            break;
        }
    }
    return n_find;
}

bool Val_In_Wood(Node* root, float val){
    if (Search(root, val) != NULL){
        return true;
    }
    return false;
}

bool Modification_Node_Data(Node* n, float val){
    if (n == NULL){
        return false;
    }
    n->data = val;
    return true;
}

void Paint(Node* n, int deep){
    for (int j = 0; j < deep; j++){
        printf("    ");
    }
    printf("%f\n", n->data);
    for (int i = 0; i < n->degree; i++){
        Paint(n->foliage[i], deep+1);
    }
    return;
}


//---------------------------------------
//ОСНОВНАЯ ПРОГА

int main(){
    char stat = 'e';
    float val = 0;
    float val_father = 0;
    
    Wood* wood = malloc(sizeof(struct Wood));
    if (!wood){
        return 1;
    }
    Node* root = malloc(sizeof(struct Node));
    if (!root){
        return 1;
    }
    Create(root);
    wood->degree = 0;
    wood->vertex_count = 1;
    wood->vertex_root = root;
    printf("Добро пожаловать!\n");
    printf("На данный момент дерева не существует. Введите значение корневого узла: ");
    scanf(" %f", &val);
    root->data = val;
    printf("Дерево успешно создано!\n\n");
    printf("----------------------------------\n\n");
    
    
    while ((stat != 'Q') && (stat != 'q')) {
        printf("M для изменения значения узла,\nC для добавления узла,\nD для удаления узла,\nP для текстовой визуализации,\nA для подсчёта количества вершин,\nQ для выхода,\nH для более подробного описания команд.\nВведите букву команды: ");
        scanf(" %c", &stat);
        
        switch(stat){
            
            case 'M':
            case 'm':
            {
                printf("Введите старое значение узла: ");
                scanf(" %f", &val_father);
                printf("Введите новое значение узла: ");
                scanf(" %f", &val);
                if (Modification_Node_Data(Search(root, val_father), val)){
                    printf("Значение изменено.\n\n");
                } else {
                    printf("Узел не найден.\n\n");
                }
            }
            break;
                
            case 'C':
            case 'c':
            {
                printf("Введите значение для нового узла: ");
                scanf(" %f", &val);
                printf("Введите значение отцовского узла: ");
                scanf(" %f", &val_father);
                if (Val_In_Wood(root, val)){
                    printf("Узел с таким значением уже существует.\n\n");
                } else if (Push(wood, Search(root, val_father), val)){
                    printf("Узел добавлен.\n\n");
                } else{
                    printf("Память не выделена, количество потомков у узла превышено или узел не найден.\n\n");
                }
            }
            break;
                
            case 'D':
            case 'd':
            {
                printf("Введите значение удаляемого узла: ");
                scanf(" %f", &val_father);
                if (Pop(wood, Search(root, val_father))){
                    printf("Узел удалён.\n\n");
                } else{
                    printf("Попытка удаления корневого узла или узел не найден.\n\n");
                }
            }
            break;
            
            case 'P':
            case 'p':
            {
                Paint(root, 0);
                printf("\n");
            }
            break;
            
            case 'A':
            case 'a':
            {
                printf("Степень дерева: %d\n", wood->degree);
                printf("Количество вершин в дереве: %d\n\n", wood->vertex_count);
            }
            break;
            
            case 'H':
            case 'h':
            {
                printf("M (Modification) -- позволяет изменить значение любого узла, в т.ч. корневого, без потери предков и потомков.\n");
                printf("C (Create) -- позволяет создать новый узел дерева, прикрепив к любому другому узлу.\n");
                printf("D (Delete) -- позволяет удалить любой узел дерева, кроме корневого. Все поддеревья, исходящие из удаляемого узла, также будут удалены. Для обнуления всего дерева перезагрузите программу.\n");
                printf("P (Painting) -- позволяет в текстовом формате визуализировать дерево.\n");
                printf("A (Account) -- выводит общее количество вершин в дереве с учётом корневого, а также степень дерева.\n");
                printf("Q (Quit) -- выход из программы. При этом существующее дерево полностью удаляется.\n\n");
            }
            break;
        } 
    } 
    printf("\n----------------------------------\n\nУдаление дерева...\n");
    for (int i = root->degree-1; i >= 0; i--){
        Pop(wood, root->foliage[i]);
    }
    free(root);
    wood->vertex_root = NULL;
    free(wood);
    printf("До свидания!\n\n----------------------------------\n");
    return 0;
}
```

7. **Замечания автора** по существу работы: далеко не все функции были реализованы эффективным образом. Есть возможность оптимизировать программу, в том числе с помощью новых структур, таких как очередь.
Есть возможность дорабатывать программу. Нет проверки ввода корректных данных, так что программа может вести себя непредсказуемо.
8. **Выводы**: мне очень понравилось выполнять данную лабораторную работу. Она заняла довольно много времени, однако это того стоило. Сначала было сложно программировать, но как только я приловчилась
пользоваться объявлением новых структур и ссылками на них, работа закипела. В программу я добавила сохранение некоторых данных, не востребованных для поставленной задачи, однако они помогут в будущем
доработать код и добавить иные функции менее "болезненно". Полученные знания и опыт помогут в дальнейшем при программировании, расширили мои возможности.
